%
%   Copyright 2020 Amir Kantor
%
%   Licensed under the Apache License, Version 2.0 (the "License");
%   you may not use this file except in compliance with the License.
%   You may obtain a copy of the License at
%
%       http://www.apache.org/licenses/LICENSE-2.0
%
%   Unless required by applicable law or agreed to in writing, software
%   distributed under the License is distributed on an "AS IS" BASIS,
%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%   See the License for the specific language governing permissions and
%   limitations under the License.
%

% ___File name:___ horn-interpreter.pl

% ___File purpose:___ A Horn-logic interpreter implemented in ISO Prolog. It is
% implemented as a Prolog knowledge base -- a meta-interpreter.

% Prolog Knowledge Base
% =====================

% NOTE The following predicates are considered input to this file:
% `horn_pl__clause/2`, `horn_pl__asserta/1`. They are defined in the Prolog
% module generated by `/app/horc/src/bash/generate-temp-module.sh`.

% The following clause successively unifies `Head` and `BodyList` with the
% head and the body of a consulted knowledge base's clause, according to the
% order of the clauses in the knowledge base. `BodyList` is in the form
% of a _list_ of conjuncts (terms).
clause_list(Head, BodyList) :-
    horn_pl__clause(Head, Body), % NOTE Usage.
    conjugates_to_list_rec(Body, BodyList).
%
% The following clause turns a clause body into a *list* of conjuncts.
conjugates_to_list_rec(true, []).
conjugates_to_list_rec((A,B), ListAB) :-
    conjugates_to_list_rec(A, ListA),
    conjugates_to_list_rec(B, ListB),
    append(ListA, ListB, ListAB).
conjugates_to_list_rec(OtherTerm, [OtherTerm]) :-
    OtherTerm \= true,
    OtherTerm \= (_,_).

% In this clause, given a list of goals `GoalList`, a nonnegative integer
% depth limit `Limit`, and an output argument `Result`, the variables in
% `GoalList` and the argument `Result` are successively unified with
% either solutions of the query `GoalList` up to the depth limit (!) -- 
% in which case `Result` is unified with the depth in which the solution 
% was found -- as well as with intermediate results obtained when a search path
% exceeds the depth limit -- in which case `Result` is unified with
% `depth_limit_exceeded`. The search tree corresponding to the query is
% traversed in a DEPTH-FIRST manner, and up to the indicated DEPTH
% LIMIT. Furthermore, all the unifications that are performed as part of
% the query include "occurs-checks"; that is, the unification of a
% variable with a term succeeds (if and) only if the variable doesn't
% occur in the term, or it is the whole term. This results in SOUND
% UNIFICATION for Horn logic.
% Consequently, this inference method always terminates, it finds all
% (sound) Horn-logic solutions up to depth `Limit`, and only those, as
% well as all situations in which a deeper search may POSSIBLY lead to
% more solutions. It is therefore SOUND for Horn logic, and, in a sense,
% "complete" w.r.t the given depth limit.
call_horn_with_limit_raw(GoalList, Limit, Result) :-
    (   integer(Limit),
        Limit >= 0
    ->  call_horn_with_limit_rec(GoalList, Limit, 0, Result)
    ;   throw('horn:call_horn_with_limit_raw/3: bad argument')
    ).
%
% An auxiliary predicate:
call_horn_with_limit_rec([], _, Depth, Depth).
call_horn_with_limit_rec([_|_], Limit, Limit, depth_limit_exceeded).
call_horn_with_limit_rec([Goal|RestGoals], Limit, Depth, Result) :-
    Depth < Limit,
    functor(Goal, F, Arity),
    functor(Head, F, Arity),
    clause_list(Head, BodyList),
    unify_with_occurs_check(Goal, Head),
    append(BodyList, RestGoals, AllGoals),
    NewDepth is Depth + 1,
    call_horn_with_limit_rec(AllGoals, Limit, NewDepth, Result).

% In this clause, given a list of goals `GoalList`, a nonnegative integer depth
% limit `Limit`, and an output argument `Result`, the variables in `GoalList`
% and the argument `Result` are successively unified with all solutions
% of the query `GoalList` that don't exceed the depth limit -- in which
% case, `Result` is unified with the depth in which the solution was
% found. Then, it is checked whether or not there exists a search path
% that exceeds the depth limit. If yes, `Result` is unified with
% `depth_limit_exceeded` and the query succeeds (no other unifications
% are introduced); if not, the query fails. The search tree
% corresponding to the query is traversed in a DEPTH-FIRST manner, and
% up to the indicated DEPTH LIMIT. Furthermore, all the unifications
% that are performed as part of the the query include "occurs-checks";
% that is, the unification of a variable with a term succeeds (if and)
% only if the variable doesn't occur in the term, or it is the whole
% term. This results in SOUND UNIFICATION for Horn logic.
% Consequently, this inference method always terminates, it finds all
% (sound) Horn-logic solutions up to depth `Limit`, and only those, and
% signals whether or not a deeper search may possibly lead to more
% solutions. It is therefore SOUND for Horn logic, and, in a sense,
% "complete" w.r.t the given depth limit.
% NOTE This predicate adopts (and conforms to) the contract of
% SWI-prolog's `call_with_depth_limit/3` (version 7.2.2), except that
% here unification is sound (this is equivalent to executing
% `call_with_depth_limit/3` with SWI-Prolog's `occurs_check` flag set
% to `true`).
% NOTE `call_with_depth_limit/3` shouldn't be used as I think
% I found a bug (in version 7.2.2).
% TODO It is inefficient to invoke `call_horn_with_limit_raw/3` for the
% second time (to check for an exceeding path). Is there a way around it?
call_horn_with_limit(GoalList, Limit, Result) :-
    (   integer(Limit),
        Limit >= 0
    ->  (   call_horn_with_limit_raw(GoalList, Limit, Result),
            Result \= depth_limit_exceeded
        ;   (   \+ call_horn_with_limit_raw(GoalList, Limit, 
                                            depth_limit_exceeded)
            ->  %format('--- There are NO more solutions ---\n'),
                false
            ;   %format('--- There are POSSIBLY more solutions ---\n'),
                Result = depth_limit_exceeded
            )
        )
    ;   throw('horn:call_horn_with_limit/3: bad argument')
    ).

% In this clause, given a list of goals `GoalList`, a nonnegative integer 
% `LimitStart`, a strictly positive integer `LimitStep`, and output arguments
% `ResultLimit` and `ResultDepth`, The variables in `GoalList` and
% the output arguments are successively unified with all solutions of
% the query `GoalList`. `ResultLimit` is unified with the depth limit
% that is in-effect for the returned solution (see below), and
% `ResultDepth` is unified with the solution's depth in the search tree.
% The search tree corresponding to the query is traversed in a
% DEPTH-FIRST ITERATIVE-DEEPENING manner. That is, starting from depth
% limit `LimitStart`, the search tree is traversed in a depth-first
% manner up to the depth limit. Then, in case that there exists a search path
% that exceeds the depth limit, the limit is raised by the value `LimitStep`
% (and so on). Otherwise, the search terminates. Furthermore, all the
% unifications that are performed as part of the the query include
% "occurs-checks"; that is, the unification of a variable with a term
% succeeds (if and) only if the variable doesn't occur in the term, or
% it is the whole term. This results in SOUND UNIFICATION for Horn logic.
% Consequently, this inference method finds all (sound) Horn-logic
% solutions, and only those. It is therefore both SOUND and COMPLETE for
% Horn logic. Note, however, that the execution of a query doesn't
% necessarily terminate, even if there are no more solutions.
call_horn(GoalList, LimitStart, LimitStep, ResultLimit, ResultDepth) :-
    (   integer(LimitStart),
        LimitStart >= 0,
        integer(LimitStep),
        LimitStep > 0
    ->  format('------------ Limit = ~d ------------\n', LimitStart),
        call_horn_with_limit(GoalList, LimitStart, Result0),
        (   Result0 = depth_limit_exceeded
        ->  NextLimitStart is LimitStart + LimitStep,
            call_horn(GoalList, NextLimitStart, LimitStep, ResultLimit,
                      ResultDepth)
        ;   ResultLimit = LimitStart,
            ResultDepth = Result0
        )
    ;   throw('horn:call_horn/5: bad argument')
    ).

% Clause is same as `call_horn/5`, but with a goal `Goal` that is a single
% term, `LimitStart` equals 0, and there are no output arguments `ResultLimit`
% and `ResultDepth`.
horn(Goal, LimitStep) :-
    call_horn([Goal], 0, LimitStep, _, _).

% Clause verifies `Goal` and adds it to the knowledge base once verified.
hornadd(Goal, LimitStep) :-
    horn(Goal, LimitStep),
    horn_pl__asserta(Goal). % NOTE Usage.

% The following clause adds `Clause` to the knowledge base w/o verifying it.
skiphornadd(Clause) :-
    horn_pl__asserta(Clause). % NOTE Usage.

% Comments
% --------

% TODO Verify compliance to ISO Prolog.

% TODO Consider improving efficiency by adding cuts and other optimizations.

% TODO Consider including annotations on some of the arguments of the defined
% predicates, in order to precisely indicate necessary assumptions and
% restrictions, where applicable.
